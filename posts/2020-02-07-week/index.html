<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Maximilian Götzfried"/><link rel="canonical" href="www.mxgzf.com/posts/2020-02-07-week"/><meta name="twitter:url" content="www.mxgzf.com/posts/2020-02-07-week"/><meta name="og:url" content="www.mxgzf.com/posts/2020-02-07-week"/><title>NSSearchField, NSApplicationCrashOnExceptions, Audiograph, Not taking feedback personally, Play | Maximilian Götzfried</title><meta name="twitter:title" content="NSSearchField, NSApplicationCrashOnExceptions, Audiograph, Not taking feedback personally, Play | Maximilian Götzfried"/><meta name="og:title" content="NSSearchField, NSApplicationCrashOnExceptions, Audiograph, Not taking feedback personally, Play | Maximilian Götzfried"/><meta name="description" content="This is what i learned in the past few weeks"/><meta name="twitter:description" content="This is what i learned in the past few weeks"/><meta name="og:description" content="This is what i learned in the past few weeks"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Maximilian Götzfried"/></head><body><div class="content pure-u-1 pure-u-md-3-5 pure-u-xl-6-10"><h2>NSSearchField, NSApplicationCrashOnExceptions, Audiograph, Not taking feedback personally, Play</h2><p>published on <time datetime="2020-26-01" title="Jan 26, 2020">Jan 26, 2020</time datetime="2020-26-01" title="Jan 26, 2020"> by <a href="www.mxgzf.com">Maximilian Götzfried</a></p><div class="post-description"><div><p>This is what i learned in the past few weeks:</p><h3>macOS will soon support universal apps</h3><blockquote><p>Starting in March 2020, you’ll be able to distribute iOS, iPadOS, macOS, and tvOS versions of your app as a universal purchase, allowing customers to enjoy your app and in‑app purchases across platforms by purchasing only once. – https://developer.apple.com/news/?id=02052020a</p></blockquote><p>…</p><blockquote><p>This has the potential to be great news for MacOS developers who want to create iOS apps and don’t want to devalue the products on either platform. I could imagine a situation where a Mac developer sells an app for $50 and wants to create an iOS app, but might struggle to find buyers for it at $10. Instead, they could charge $70 or $80 for the bundle. – https://pxlnv.com/linklog/macos-universal-apps/</p></blockquote><p>It's not a bundle, though. It's a single purchase with a constant price.</p><p>For example, $49 USD might be resonable price for a Mac productivity app. But released as a universal app, $49 USD will also be the price for the iPhone app. It is crucial to make it clear to the potential buyer that this price also covers the iPad and the Mac app. But even if you succeed at making that clear, remember: A lot of people with iPhones don't have a Mac or don't have interest in a Mac version of your app for some other reasons. But these people have to pay the same "bundle" price of $49 USD.</p><p>(…)</p><blockquote><p>I have mixed feelings about this. It’s great that this is now possible. But higher Mac app prices have helped many developers of one-time purchase apps to generate enough revenue to stay in business. This might become harder now. I’m biased here, but I think Apple sees one-time purchases on the way out. If they wanted to help those developers, a paid upgrade system would have been the right step. But Apple pushes services so the following is probably the main motivation: Download a free app on a Mac and it will automatically install on all iOS devices. Using a single cross-platform subscription, customers can unlock the app on all devices. For developers this means they no longer need to roll out their own servers to make cross-platform subs work – <a href="https://mindnode.com">Markus Müller Simhofer</a> on <a href="https://twitter.com/MuellerSimhofer/status/1225144424327524354">Twitter</a>, Feb 5, 2020</p></blockquote><blockquote><p>We asked for trials and upgrades to make the Mac App Store sustainable. We got a new way of giving our Mac software away for free. Gee thanks! – <a href="https://www.publicspace.net/mac.html">Frank Reiff</a> on <a href="https://twitter.com/frankreiff/status/1225156409504997376">Twitter</a>, Feb 5, 2020</p></blockquote><blockquote><p>Hooray for further devaluation of the amount of actual work it takes to be a good app on multiple platforms! – <a href="https://tapbots.com">Paul Haddad</a> on <a href="https://twitter.com/tapbot_paul/status/1225147208498020352">Twitter</a>, Feb 5, 2020</p></blockquote><h3>The weird connection between border and bezel of <code>NSSearchField</code></h3><p>Setting <code>NSSearchField.isBordered</code> to either <code>true</code> or <code>false</code> after setting the <code>NSSearchField.bezelStyle</code>, the bezel will <em>not</em> be applied properly. So if you want <code>.bezelStyle = .roundedBezel</code> it is better to not set <code>isBordered</code> at all.</p><p>I think we can file that under "AppKit weirdness".</p><p>And yes, i'm creating the UI of this Mac app programmatically. I've learned my lesson after loosing many hours by merging storyboards, xibs and nibs for several clients in the past decade.</p><h3>NSApplicationCrashOnExceptions</h3><p>A post in the Apple dev forum reminded fellow developers about AppKit default exception handling:</p><blockquote><p>“AppKit has a default exception handler that catches all language exceptions raised by code run from its run loop. It logs the exception and then swallows it, allowing the app to continue running. Who thought that was a good idea!?!” – https://forums.developer.apple.com/thread/128559</p></blockquote><p>The best documentation about the <code>NSApplicationCrashOnExceptions</code> key has Microsoft:</p><blockquote><p>AppKit catches exceptions thrown on the main thread, preventing the application from crashing on macOS, so the SDK cannot catch these crashes. To mimic iOS behavior, set NSApplicationCrashOnExceptions flag before SDK initialization, this will allow the application to crash on uncaught exceptions and the SDK can report them. <code>UserDefaults.standard.register(defaults: ["NSApplicationCrashOnExceptions": true])</code> – https://docs.microsoft.com/en-us/appcenter/sdk/crashes/macos</p></blockquote><p>More:</p><ul><li>https://openradar.appspot.com/41809382</li><li>https://github.com/microsoft/appcenter-sdk-apple/issues/1725</li><li>https://docs.fabric.io/apple/crashlytics/os-x.html</li><li>https://siddarthkalra.github.io/2019/04/19/uncaught-exceptions-macos.html</li><li>https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Exceptions/Exceptions.html</li></ul><h3>Visualizing charts through audio for visually impaired people</h3><p><a href="https://github.com/Tantalum73/Audiograph">Audiograph</a> by <a href="https://anerma.de">Andreas Neusüß</a> is a great framework that visualizes charts through audio for visually impaired people. A new feature of iOS 13 that is not available as a public API yet.</p><p>Check the videos in the <a href="https://github.com/Tantalum73/Audiograph">README</a> or <a href="https://twitter.com/Klaarname/status/1223993809413005313">this tweet</a> to see in action.</p><h3>Not taking feedback personally is the hardest part</h3><p>This is the hardest part about receiving feedback as a developer:</p><blockquote><p>#### 3. Don’t take it personally This tip has been a game-changer for me. For the longest time, I took feedback personally. If somebody pointed out that an animation wasn’t smooth, or that a label is misaligned it felt as if they were critiquing <em>me</em>. All I would hear is that I didn’t do a good enough job implementing a design, or that my coding isn’t good enough. Detaching yourself from your work is really hard, but I found that it makes receiving feedback a lot easier. – <a href="https://www.donnywals.com/five-ways-to-get-better-at-receiving-feedback/">Five ways to get better at receiving feedback</a> by <a href="https://www.donnywals.com">Donny Wals</a></p></blockquote><p>TODO: Creativity. Dreaming about code at night, etc. // I have a personal connection with the code that i wrote // independent developers: sweating for their product.</p><h2>How to find the location of file under a directory tree?</h2><p>Me in 2018 on <a href="https://stackoverflow.com/a/49764689/251839">Stack Overflow</a>:</p><blockquote><p>One option is to manually enumerate the directories: <code></code>`swift func manualSearchFile(withName name: String, in path: String) { func search(url: URL) { do { let contents = try FileManager.default.contentsOfDirectory(at: url, includingPropertiesForKeys: [.nameKey, .pathKey, .isDirectoryKey], options: []) try contents.forEach { let metadata = try $0.resourceValues(forKeys: [.nameKey, .pathKey, .isDirectoryKey]) if metadata.name == name { print("Manual Found: (metadata.path ?? "unknown path")") } if metadata.isDirectory == true { search(url: $0) } } } catch { print(error) } } search(url: URL(fileURLWithPath: path)) } manualSearchFile(withName: "foo.txt", in: "/bar/directory") <code></code>` Another option is to use Spotlight, which is faster but only works for paths that are indexed. Many system directories are excluded and users can exclude even more in System Preferences &gt; Spotlight &gt; Privacy. <code></code>`swift var metadataQuery: NSMetadataQuery? func spotlightSearchFile(withName name: String, in path: String) { NotificationCenter.default.addObserver(forName: .NSMetadataQueryDidFinishGathering, object: nil, queue: nil) { guard let query = $0.object as? NSMetadataQuery else { return } query.enumerateResults { (result, index, cancel) in let item = result as? NSMetadataItem let path = item?.value(forAttribute: NSMetadataItemPathKey) as? String print("Spotlight Found: (path ?? "unknown path")") } } metadataQuery = NSMetadataQuery() metadataQuery?.searchScopes = [path] metadataQuery?.predicate = NSPredicate(format: "%K like[cd] %@", NSMetadataItemDisplayNameKey, name) metadataQuery?.start() } spotlightSearchFile(withName: "foo.txt", in: "/bar/directory") <code></code>` For more information about the query syntax see the <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Predicates/Articles/pSpotlightComparison.html">Comparison of NSPredicate and Spotlight Query Strings</a>. In the old days we used to have more options with <code>FSCatalogSearch</code> and <code>FSGetCatalogInfoBulk</code>. But these are no longer available, AFAIK.</p></blockquote><p>Repeated without quote:</p><p>One option is to manually enumerate the directories:</p><pre><code><span class="keyword">func</span> manualSearchFile(withName name: <span class="type">String</span>, in path: <span class="type">String</span>) {

 <span class="keyword">func</span> search(url: <span class="type">URL</span>) {
     <span class="keyword">do</span> {
         <span class="keyword">let</span> contents = <span class="keyword">try</span> <span class="type">FileManager</span>.<span class="property">default</span>.<span class="call">contentsOfDirectory</span>(at: url, includingPropertiesForKeys: [.<span class="dotAccess">nameKey</span>, .<span class="dotAccess">pathKey</span>, .<span class="dotAccess">isDirectoryKey</span>], options: [])
         <span class="keyword">try</span> contents.<span class="call">forEach</span> {
             <span class="keyword">let</span> metadata = <span class="keyword">try</span> $0.<span class="call">resourceValues</span>(forKeys: [.<span class="dotAccess">nameKey</span>, .<span class="dotAccess">pathKey</span>, .<span class="dotAccess">isDirectoryKey</span>])
             <span class="keyword">if</span> metadata.<span class="property">name</span> == name {
                 <span class="call">print</span>(<span class="string">"Manual Found:</span> \(metadata.<span class="property">path</span> ?? "unknown path")<span class="string">"</span>)
             }
             <span class="keyword">if</span> metadata.<span class="property">isDirectory</span> == <span class="keyword">true</span> {
                 <span class="call">search</span>(url: $0)
             }
         }
     } <span class="keyword">catch</span> {
         <span class="call">print</span>(error)
     }
 }

 <span class="call">search</span>(url: <span class="type">URL</span>(fileURLWithPath: path))
}
<span class="call">manualSearchFile</span>(withName: <span class="string">"foo.txt"</span>, in: <span class="string">"/bar/directory"</span>)
</code></pre><p>Another option is to use Spotlight, which is faster but only works for paths that are indexed. Many system directories are excluded and users can exclude even more in System Preferences &gt; Spotlight &gt; Privacy.</p><pre><code><span class="keyword">var</span> metadataQuery: <span class="type">NSMetadataQuery</span>?
<span class="keyword">func</span> spotlightSearchFile(withName name: <span class="type">String</span>, in path: <span class="type">String</span>) {

 <span class="type">NotificationCenter</span>.<span class="property">default</span>.<span class="call">addObserver</span>(forName: .<span class="dotAccess">NSMetadataQueryDidFinishGathering</span>, object: <span class="keyword">nil</span>, queue: <span class="keyword">nil</span>) {

     <span class="keyword">guard let</span> query = $0.<span class="property">object</span> <span class="keyword">as</span>? <span class="type">NSMetadataQuery</span> <span class="keyword">else</span> { <span class="keyword">return</span> }
     query.<span class="call">enumerateResults</span> { (result, index, cancel) <span class="keyword">in

         let</span> item = result <span class="keyword">as</span>? <span class="type">NSMetadataItem</span>
         <span class="keyword">let</span> path = item?.<span class="call">value</span>(forAttribute: <span class="type">NSMetadataItemPathKey</span>) <span class="keyword">as</span>? <span class="type">String</span>
         <span class="call">print</span>(<span class="string">"Spotlight Found:</span> \(path ?? "unknown path")<span class="string">"</span>)
     }
 }

 metadataQuery = <span class="type">NSMetadataQuery</span>()
 metadataQuery?.<span class="property">searchScopes</span> = [path]
 metadataQuery?.<span class="property">predicate</span> = <span class="type">NSPredicate</span>(format: <span class="string">"%K like[cd] %@"</span>, <span class="type">NSMetadataItemDisplayNameKey</span>, name)
 metadataQuery?.<span class="call">start</span>()
}
<span class="call">spotlightSearchFile</span>(withName: <span class="string">"foo.txt"</span>, in: <span class="string">"/bar/directory"</span>)
</code></pre><p>For more information about the query syntax see the <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Predicates/Articles/pSpotlightComparison.html">Comparison of NSPredicate and Spotlight Query Strings</a>.</p><p>In the old days we used to have more options with <code>FSCatalogSearch</code> and <code>FSGetCatalogInfoBulk</code>. But these are no longer available, AFAIK.</p></div></div></div><p>◼</p></body></html>